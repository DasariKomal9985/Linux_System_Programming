exec() is a family of system calls used to:

Replace the current process with a new program.

Same PID
Same open file descriptors (unless marked close-on-exec)
Same environment variables
Same working directory
BUT completely new text, data, heap, stack, and instructions

It does NOT create a new process ‚Äî it replaces the calling process.


IMPORTANT: exec() NEVER RETURNS (if successful)

If exec() succeeds:
your old program‚Äôs code disappears
your old variables disappear
your old functions disappear
the new program starts from main()
The ONLY case where exec returns is:
‚úî if exec fails (file not found, permission denied, etc.)



Why do we need exec()?

Because in Linux, process creation is 2-step:

‚úî Step 1: fork() creates a new process
‚úî Step 2: exec() loads a new program into that process

bash:
    fork()
        child
            exec("/bin/ls")
    parent
        wait()



exec family: different functions, same purpose


| Function      | When used                             |
| ------------- | ------------------------------------- |
| **execl()**   | Pass arguments as list                |
| **execv()**   | Pass arguments as array of char*      |
| **execle()**  | List + environment                    |
| **execve()**  | THE ACTUAL system call                |
| **execvp()**  | Uses PATH variable (common in shells) |
| **execvpe()** | PATH + environment                    |


All finally call execve() in kernel.




execve() Prototype (actual system call)

int execve(const char *pathname, char *const argv[], char *const envp[]);
‚úî pathname ‚Üí executable path
‚úî argv ‚Üí argument list (argv[0] = program name)
‚úî envp ‚Üí environment variables




Memory BEFORE and AFTER exec()

Before exec():
Parent fork()
  ‚Üì
Child
  ‚îú‚îÄ‚îÄ same code as parent
  ‚îú‚îÄ‚îÄ same variables
  ‚îú‚îÄ‚îÄ same heap/stack
  ‚îú‚îÄ‚îÄ same file descriptors


After exec():
Child becomes NEW PROGRAM
  ‚îú‚îÄ‚îÄ new code (from executable)
  ‚îú‚îÄ‚îÄ new data/stack/heap
  ‚îú‚îÄ‚îÄ SAME PID
  ‚îú‚îÄ‚îÄ SAME open file descriptors


Only file descriptors survive exec ‚Äî unless FD_CLOEXEC flag is set.


exec() does NOT create new PID

PID = 1234
fork() ‚Üí child PID = 1235
child exec("/bin/ls") ‚Üí PID still 1235

Only the ‚Äúprogram inside the process‚Äù changes.




How exec() actually works inside the kernel

Load ELF executable from disk
Free current process memory (text, data, heap)
Replace with new program image
Set up new stack (argv, envp)
Set program entry point (main)
Jump to entry point ‚Üí new program starts executing



What if exec fails?
Reasons:
file not executable
permission denied
wrong path
insufficient memory



üî• execve() ‚Üí the actual system call.


| Function    | Takes PATH search? | Arguments type | Environment control    |
| ----------- | ------------------ | -------------- | ---------------------- |
| **execl**   | NO                 | list           | NO                     |
| **execlp**  | YES                | list           | NO                     |
| **execle**  | NO                 | list           | YES                    |
| **execv**   | NO                 | array          | NO                     |
| **execvp**  | YES                | array          | NO                     |
| **execvpe** | YES                | array          | YES                    |
| **execve**  | NO                 | array          | YES (root system call) |



üü¶ 1. execl() ‚Äî exec using LIST of arguments

int execl(const char *path, const char *arg0, ..., NULL);

Features:
Uses full path (NO PATH searching)
Pass arguments as comma-separated list
Ends with NULL



#include <unistd.h>
#include <stdio.h>

int main() {
    execl("/bin/ls", "ls", "-l", NULL);

    // If this executes, exec failed
    perror("execl failed");
}




Why a New Process?

One program = One job
Shell: parses commands, manages environment, provides prompt
ls: lists directory contents
cat: prints files
grep: searches text
pwd: prints working directory



Each is a separate executable file.

Shell does NOT want to ‚Äúmix‚Äù its memory with that of programs.




If the shell ran ls inside its own process:

It would overwrite its own memory
It could crash itself
It would lose its prompt, variables, environment




Instead:

The safe design:
Shell creates a child process (fork)
The child process replaces itself with ls (exec)
Shell waits
When ls is done, child exits
Shell continues cleanly



What Happens If Shell Never Used fork()?


Shell directly runs ls code inside itself:
Shell memory gets replaced
After ls prints, there is no shell left to return to
No prompt
No environment
No variables
No ability to run next command
Your terminal would disappear after executing one command.



So without fork() + exec():

The shell would self-destruct every time you run a command.



7. Why Still Use fork() When exec() Replaces the Child Anyway?


fork() creates a new safe process.
exec() overwrites only the child, never the shell.
fork() ensures the parent shell survives.


Analogy

ls -l

The manager does NOT do the work itself.
It hires a worker (fork),
gives him the job to do (exec),
waits for him to finish,
collects the results,
and stays available for more commands.




1. Program Path (Executable Path)
This is the location of the executable file that you want to run



/bin/ls
/usr/bin/cobra4
/home/anaconda/a.out

‚úî Absolute path
/usr/bin/gcc
/bin/cat


‚úî Relative path
./a.out
../scripts/run




2. Argument List (Command-Line Arguments)
Arguments are the inputs passed to the program when it starts.

ls -l -a /home


| Index   | Value      |
| ------- | ---------- |
| argv[0] | "ls"       |
| argv[1] | "-l"       |
| argv[2] | "-a"       |
| argv[3] | "/home"    |
| argv[4] | NULL (end) |


argv[0] is always the program name (convention)
Arguments appear exactly as typed
They tell the program how to behave
-l means long listing
/home is target directory




‚úî List (l-series)
execl("/bin/ls", "ls", "-l", "-a", "/home", NULL);



‚úî Vector/array (v-series)
char *args[] = {"ls", "-l", "-a", "/home", NULL};
execv("/bin/ls", args);





3. Environment Variables (envp)
Environment variables are global key-value settings for a process.


PATH=/usr/bin:/bin
HOME=/home/eswar
USER=mamba
LANG=en_US.UTF-8
PWD=/home/Anaconds/projects


They store configuration about:
user identity
directory locations
language
executable search path
terminal type

In exec:

Normal exec variants (execl, execv, execlp, execvp) inherit environment variables.
execle and execve allow you to replace environment variables.



